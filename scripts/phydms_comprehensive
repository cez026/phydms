#!python

"""Comprehensive model comparison and selection-detection with ``phydms``.

Written by Jesse Bloom and Sarah Hilton."""


import sys
import os
import re
import time
import copy
import logging
import multiprocessing
import subprocess
import glob
import phydmslib
import phydmslib.file_io
import phydmslib.parsearguments
import pandas as pd

def RunCmds(cmds):
    """Runs the command line arguments in *cmds* using *subprocess*."""
    try:
        p = subprocess.Popen(cmds, stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT)
        pid = p.pid
        (stdout, stderr) = p.communicate()
    except:
        os.kill(pid, signal.SIGTERM)

def createModelComparisonFile(models, outprefix):
    """
    Creates two summary files, a .csv and a .md

    *modelcomparison.csv*
        Columns include 'model', 'variable', 'value'
        'variable' includes all of the optimized parameters, the final log
        likelihood and the number of optimized parameters.
    *modelcomparison.md*
        Columns include 'model', 'Loglikelihood', 'deltaAIC', and all non-phi
        optimized parameters.
    """

    #modelcomparison.csv
    final = pd.DataFrame({"Model":[],"variable":[], "value":[]})
    for modelName in models.keys():
        df = pd.read_csv(outprefix + modelName + "_modelparams.txt",
                sep = " = ", header = None, engine = 'python')
        df.columns = ['variable', 'value'] #rename the columns
        df["Model"] = [modelName for x in range(len(df))] #add the model column
        df = pd.concat([df, pd.DataFrame({"Model":[modelName],"variable":\
                ["nEmpiricalParams"], "value":[len(df)]})])
        final = pd.concat([final,df])
        with open(outprefix + modelName + "_loglikelihood.txt") as f:
            temp = {"Model":[], "variable":[], "value":[]}
            lines = f.readlines()
            temp["Model"].append(modelName)
            temp["variable"].append("LogLikelihood")
            temp["value"].append(lines[0].split(" = ")[-1])
        final = pd.concat([final, pd.DataFrame(temp)])
    final.to_csv(outprefix + "modelcomparison.csv", index = False)
    final.reset_index(drop=True, inplace = True)

    #modelcomparison.md
    #pivot the dataframe so the parameters are columns
    mdDF = final.pivot(index = "Model", columns='variable', values='value')
    mdDF = mdDF[[x for x in mdDF.columns.values if "phi" not in x]]#remove phi
    mdDF["LogLikelihood"] = [float(x) for x in mdDF["LogLikelihood"]]
    #calc AIC
    mdDF["deltaAIC"] = 2 * (mdDF["nEmpiricalParams"] - mdDF["LogLikelihood"])
    mdDF["deltaAIC"] = mdDF["deltaAIC"] - mdDF["deltaAIC"].min()#calc dAIC
    mdDF.sort_values(['deltaAIC'], ascending=[True])#sort so "best" model first
    #format for markdown
    final = ["|".join(["Model"] + mdDF.columns.values)]
    final.append(["---|" for x in range(len(mdDF.columns.values))] + ["---"])
    #write markdown file
    with open(outprefix + "modelcomparison.md", "w") as f:
        f.write("|".join(["Model"] + list(mdDF.columns.values)) + "\n")
        f.write("".join(["---|" for x in range(len(mdDF.columns.values))]
                + ["---"]) + "\n")
        for index, row in mdDF.iterrows():
            f.write("|".join([str(x) for x in [index]+ list(row)]) + "\n")


def main():
    """Main body of script."""

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSComprehensiveParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    #create output directory if needed
    outdir = os.path.dirname(args['outprefix'])
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)

    #setup files
    # file names slightly different depending on
    # whether outprefix is directory or file
    if args['outprefix'][-1] == '/':
        logfile = "{0}log.log".format(args['outprefix'])
    else:
        logfile = "{0}.log".format(args['outprefix'])
        args['outprefix'] = '{0}_'.format(args['outprefix'])
    modelcomparisonfile = '{0}modelcomparison.txt'.format(args['outprefix'])

    #Set up to log everything to logfile.
    if os.path.isfile(logfile):
        os.remove(logfile)
    logging.shutdown()
    logging.captureWarnings(True)
    versionstring = phydmslib.file_io.Versions()
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',
        level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    #print some basic information
    logger.info('Beginning execution of {0} in directory {1}\n'
            .format(prog, os.getcwd()))
    logger.info('Progress is being logged to {0}\n'.format(logfile))
    logger.info('{0}\n'.format(versionstring))
    logger.info('Parsed the following command-line arguments:\n{0}\n'
            .format('\n'.join(['\t{0} = {1}'.format(key, args[key])
            for key in args.keys()])))

    #setup models
    filesuffixlist = ['_log.log', '_tree.newick', '_loglikelihood.txt',
            '_modelparams.txt']
    filesuffixes = {} # keyed by model, values are list of suffixes
    models = {}
    additionalcmds = ["--brlen", args["brlen"]]
    if args['omegabysite']:
        additionalcmds.append('--omegabysite')
        filesuffixlist = copy.deepcopy(filesuffixlist) + ['_omegabysite.txt']

    #set up the YNGKP models
    models = {'YNGKP_M0':('YNGKP_M0', additionalcmds)}
    filesuffixes['YNGKP_M0'] = filesuffixlist
    models['YNGKP_M5'] = ('YNGKP_M5', additionalcmds)
    filesuffixes['YNGKP_M5'] = filesuffixlist

    #set up the ExpCM
    additionalcmds = copy.deepcopy(additionalcmds)
    if args['diffprefsbysite']:
        additionalcmds = copy.deepcopy(additionalcmds) + ['--diffprefsbysite']
        filesuffixlist = copy.deepcopy(filesuffixlist) + ['_diffprefsbysite.txt']
    for prefsfile in args['prefsfiles']:
        if re.search('\s', prefsfile):
            raise ValueError("There is a space in the preferences file name:\
                    {0}".format(prefsfile))
        prefsfilebase = os.path.splitext(os.path.basename(prefsfile))[0]
        modelname = 'ExpCM_{0}'.format(prefsfilebase)
        assert modelname not in filesuffixes, "Duplicate preferences file"\
                " base name {0} for {1}; make names unique even after "\
                "removing directory and extension".format(modelname, prefsfile)
        filesuffixes[modelname] = filesuffixlist
        models[modelname] = ('ExpCM_{0}'.format(prefsfile), additionalcmds)
        if not args["nogammaomega"]:
            gammaomegamodelname = '{0}_gammaomega'.format(modelname)
            models[gammaomegamodelname] = ('ExpCM_{0}'.format(prefsfile),
                    additionalcmds + ['--gammaomega'])
            filesuffixes[gammaomegamodelname] = filesuffixlist
        if not args['noavgprefs']:
            avgmodelname = 'averaged_{0}'.format(modelname)
            models[avgmodelname] = ('ExpCM_{0}'.format(prefsfile),
                    additionalcmds + ['--avgprefs'], 0)
            filesuffixes[avgmodelname] = filesuffixlist
            if not args["nogammaomega"]:
                avgmodelname = 'averaged_{0}_gammaomega'.format(modelname)
                models[avgmodelname] = ('ExpCM_{0}'.format(prefsfile),
                        additionalcmds + ['--gammaomega'] \
                        + ['--avgprefs'], 0)
                filesuffixes[avgmodelname] = filesuffixlist
        if args['randprefs']:
            randmodelname = 'randomized_{0}'.format(modelname)
            models[randmodelname] = ('ExpCM_{0}'.format(prefsfile),
                    additionalcmds + ['--randprefs'], 0)
            filesuffixes[randmodelname] = filesuffixlist
            if not args["nogammaomega"]:
                randmodelname = 'randomized_{0}_gammaomega'.format(modelname)
                models[randmodelname] = ('ExpCM_{0}'.format(prefsfile),
                        additionalcmds + ['--gammaomega'] \
                        + ['--randprefs'], 0)
                filesuffixes[randmodelname] = filesuffixlist

    # check alignment
    logger.info('Checking that the alignment {0} is valid...'
            .format(args['alignment']))
    alignment = phydmslib.file_io.ReadCodonAlignment(args['alignment'],
            checknewickvalid=True) #checks that the identifiers are unique
    assert len(set([align[1] for align in alignment])) == len([align[1]
            for align in alignment]), "Remove duplicate sequences from {0}."\
                    .format(args["alignment"])
    logger.info('Valid alignment specifying {0} sequences of length {1}.\n'
            .format(len(alignment), len(alignment[0][1])))

    #read or build a tree
    if args["tree"]:
      logger.info("Reading tree from {0}".format(args['tree']))
    else:
        logger.info("Tree not specified.")
        try:
            raxmlversion = subprocess.check_output([args['raxml'], '-v'],
                    stderr=subprocess.STDOUT).strip()
            logger.info("Inferring tree with RAxML using command {0}"
                    .format(args['raxml']))

            #remove pre-existing RAxML files
            raxmlOutputName = os.path.splitext(os.path.basename(
                    args["alignment"]))[0]
            raxmlOutputFiles = [n for n in glob.glob("RAxML_*{0}"
                    .format(raxmlOutputName)) if os.path.isfile(n)]
            raxmlOutputFiles = []
            for raxmlFile in glob.glob("RAxML_*{0}".format(raxmlOutputName)):
                if os.path.isfile(raxmlFile):
                    raxmlOutputFiles.append(raxmlFile)
                    os.remove(raxmlFile)
            if len(raxmlOutputFiles) > 0:
                logger.info('Removed the following RAxML files:\n{0}\n'
                    .format('\n'.join(['\t{0}'.format(fname) for
                    fname in raxmlOutputFiles])))

            # run RAxmL
            raxmlCMD = [args['raxml'], '-s', args['alignment'], '-n',
                    raxmlOutputName, '-m', 'GTRCAT', '-p1', '-T', '2']
            subprocess.check_call(raxmlCMD)

            # move RAxML tree to output directory and remove all other files
            for  raxmlFile in glob.glob("RAxML_*{0}".format(raxmlOutputName)):
                if "bestTree" in raxmlFile:
                    os.rename(raxmlFile, args["outprefix"] + raxmlFile)
                    args["tree"] = args["outprefix"] + raxmlFile
                    logger.info("RAxML inferred tree, {0}, is in {1}."
                            .format(raxmlFile, args["outprefix"]))
                else:
                    os.remove(raxmlFile)
        except OSError:
            raise ValueError("The raxml command of {0} is not valid."
                    " Is raxml installed at this path?".format(args['raxml']))

    # get number of available CPUs and assign to each model
    if args['ncpus'] == -1:
        try:
            args['ncpus'] = multiprocessing.cpu_count()
        except:
            raise RuntimeError("Encountered a problem trying to dynamically"
                    " determine the number of available CPUs. "
                    "Please manually specify the number of desired CPUs with"
                    " '--ncpus' and try again.")
            logger.info('Will use all %d available CPUs.\n' % args['ncpus'])
    assert args['ncpus'] >= 1, "Failed to specify valid number of CPUs"

    # YNGKP models get one CPU
    # ExpCM get more than one if excess over number of models
    expcm_modelnames = [modelname for modelname in models.keys() \
            if 'ExpCM' in modelname]
    yngkp_modelnames = [modelname for modelname in models.keys() \
            if 'YNGKP' in modelname]
    assert len(models.keys()) == len(expcm_modelnames) + len(yngkp_modelnames)\
            , "not ExpCM or YNGKP:\n{0}".format(str(models.keys()))
    ncpus_per_model = dict([(modelname, 1) for modelname in yngkp_modelnames])
    nperexpcm = max(1, (args['ncpus'] - 2) // len(expcm_modelnames))
    for modelname in expcm_modelnames:
        ncpus_per_model[modelname] = nperexpcm
    for modelname in models.keys():
        mtup = models[modelname]
        models[modelname] = (mtup[0], mtup[1] + ['--ncpus',
                str(ncpus_per_model[modelname])])


    pool = {} # holds process for model name
    started = {} # holds whether process started for model name
    completed = {} # holds whether process completed for model name
    outprefixes = {} # holds outprefix for model name

    # rest of execution in try / finally
    try:

        # remove existing output files
        outfiles = []
        removed = []
        for modelname in models.keys():
            for suffix in filesuffixes[modelname]:
                fname = "{0}{1}{2}".format(args['outprefix'], modelname, suffix)
                outfiles.append(fname)
        for fname in outfiles:
            if os.path.isfile(fname):
                os.remove(fname)
                removed.append(fname)
        if removed:
            logger.info('Removed the following existing files that have names'
                    " that match the names of output files that will be "
                    'created: {0}\n'.format(', '.join(removed)))

        #now run the models
        for modelname in list(models.keys()):
            (model, additionalcmds) = models[modelname]
            outprefix = "{0}{1}".format(args['outprefix'], modelname)
            cmds = ['phydms', args['alignment'], args["tree"], model,
                    outprefix] + additionalcmds
            logger.info('Starting analysis to optimize tree in {0} using model '
                    '{1}. The command is: {2}\n'.format( args["tree"],
                    modelname, ' '.join(cmds)))
            pool[modelname] = multiprocessing.Process(target=RunCmds\
                    , args=(cmds,))
            outprefixes[modelname] = outprefix
            completed[modelname] = False
            started[modelname] = False
        while not all(completed.values()):
            nrunning = list(started.values()).count(True) - \
                    list(completed.values()).count(True)
            if nrunning < args['ncpus']:
                for (modelname, p) in pool.items():
                    if not started[modelname]:
                        p.start()
                        started[modelname] = True
                        break
            for (modelname, p) in pool.items():
                if started[modelname] and (not completed[modelname]) and \
                        (not p.is_alive()): # process just completed
                    completed[modelname] = True
                    logger.info('Analysis completed for {0}'.format(modelname))
                    for fname in [outprefixes[modelname] + suffix for suffix
                            in filesuffixes[modelname]]:
                        if not os.path.isfile(fname):
                            raise RuntimeError("phydms failed to created"
                                    " expected output file {0}.".format(fname))
                        logger.info("Found expected output file {0}"\
                                .format(fname))
                    logger.info('Analysis successful for {0}\n'\
                            .format(modelname))
            time.sleep(1)

        # make sure all expected output files are there
        for fname in outfiles:
            if not os.path.isfile(fname):
                raise RuntimeError("Cannot find expected output file {0}"
                        .format(fname))
        createModelComparisonFile(models, args["outprefix"])

    except:
        logger.exception('Terminating {0} at {1} with ERROR'
                .format(prog, time.asctime()))
    else:
        logger.info('Successful completion of {0}'.format(prog))
    finally:
        logging.shutdown()
        for p in pool.values():
            if p.is_alive():
                p.terminate()


if __name__ == '__main__':
    main() # run the script
