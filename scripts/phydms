#!python

"""Phylogenetic inference using deep mutational scanning data.

Written by Jesse Bloom."""


import sys
import os
import re
import logging
import random
import time
import itertools
import math
import multiprocessing
import scipy
import scipy.stats
import Bio.Phylo
import phydmslib
import phydmslib.constants
import phydmslib.file_io
import phydmslib.parsearguments
import phydmslib.models
import phydmslib.treelikelihood


def treeliksForOmegaBySite(site, tl, prefslist, fixsyn):
    """Returns `TreeLikelihoods` for fitting omega for a site.

    The returned value can be passed to `fitOmegaBySite`."""
    if isinstance(tl.model, phydmslib.models.DistributionModel):
        modeltotype = tl.model.basemodel
    else:
        modeltotype = tl.model
    sitealignment = [(head, seq[3 * (site - 1) : 3 * site]) for 
            (head, seq) in tl.alignment]
    freeparams = [] if fixsyn else ['mu']
    treeliks = {}
    for (name, addparam) in [('fix', []), ('fit', ['omega'])]:
        if isinstance(modeltotype, phydmslib.models.ExpCM):
            assert len(prefslist) == tl.nsites
            sitemodel = phydmslib.models.ExpCM([prefslist[site - 1]], 
                    kappa=tl.model.kappa, omega=1.0, beta=tl.model.beta,
                    mu=1.0, phi=modeltotype.phi, 
                    freeparams=(freeparams + addparam))
        elif isinstance(modeltotype, phydmslib.models.YNGKP_M0):
            assert prefslist is None
            sitemodel = phydmslib.models.YNGKP_M0(modeltotype.e_pw,
                    1, kappa=tl.model.kappa, omega=1.0, mu=1.0,
                    freeparams=(freeparams + addparam))
        else:
            raise ValueError("Invalid modeltype {0}".format(modeltype))
        treeliks[name] = phydmslib.treelikelihood.TreeLikelihood(
                tl.tree, sitealignment, sitemodel, 
                branchScale=tl.model.branchScale) 
    return (site, treeliks)


def fitOmegaBySite(argtup):
    """Fits omega for a site, for use in multiprocessing pool.

    `argtup` is return value of `treeliksForOmegaBySite`.
    
    Returns tuple of P-value, tab-separated line with site, omega, P, dLnL"""
    (site, treeliks) = argtup
    logliks = {}
    for name in ['fix', 'fit']:
        result = treeliks[name].maximizeLikelihood()
        logliks[name] = treeliks[name].loglik
        if name == 'fit':
            omega = treeliks[name].model.omega
    dLnL = logliks['fit'] - logliks['fix']
    assert dLnL > -1e-3, str(logliks)
    p = scipy.stats.chi2.sf(2.0 * dLnL, df=1)
    return (p, '{0}\t{1:.3f}\t{2:.3g}\t{3:.3f}'.format(site, omega, p, dLnL))


def main():
    """Main body of script."""

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # create output directory if needed
    outdir = os.path.dirname(args['outprefix'])
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)

    # output files, remove if they already exist
    modelparamsfile = '%s_modelparams.txt' % args['outprefix']
    loglikelihoodfile = '%s_loglikelihood.txt' % args['outprefix']
    treefile = "%s_tree.newick" % args['outprefix']
    omegafile = '%s_omegabysite.txt' % args['outprefix']
    logfile = "%s.log" % args['outprefix']
    to_remove = [modelparamsfile, loglikelihoodfile, treefile, omegafile, logfile]
    for f in to_remove:
        if os.path.isfile(f):
            os.remove(f)

    # Set up to log everything to logfile.
    logging.shutdown()
    logging.captureWarnings(True)
    versionstring = phydmslib.file_io.Versions()
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',
            level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    # begin execution
    try:
        # print some basic information
        logger.info('Beginning execution of {0} in directory {1}\n'.format(
                prog, os.getcwd()))
        logger.info('Progress is being logged to {0}\n'.format(logfile))
        logger.info("{0}\n".format(versionstring))
        logger.info('Parsed the following arguments:\n{0}\n'.format(
                '\n'.join(['\t{0} = {1}'.format(*tup) for tup in args.items()])))
        logger.info('Random number seed: {0}\n'.format(args['seed']))
        random.seed(args['seed'])

        # read alignment
        logger.info('Reading alignment from {0}'.format(args['alignment']))
        alignment = phydmslib.file_io.ReadCodonAlignment(args['alignment'],
                checknewickvalid=True)
        logger.info(('Read {0} aligned sequences from {1}, each consisting '
                'of {2} codons.\n').format(len(alignment), args['alignment'],
                len(alignment[0][1]) // 3))
        seqnames = set([head for (head, seq) in alignment])

        # process the substitution model
        yngkp_match = re.compile('^YNGKP_(?P<modelvariant>M\d+)$')
        if isinstance(args['model'], str) and yngkp_match.search(args['model']):
            for argname in ['randprefs', 'avgprefs', 'divpressure']:
                assert not args[argname], "'--%s' incompatible with YNKGP".format(
                            argname)
            assert not args['gammaomega'], ("Can't use --gammaomega with YNGKP "
                    "model; use 'model' of YNGKP_M5 to achieve the same result.")
            modelvariant = yngkp_match.search(args['model']).group('modelvariant')
            logger.info(('Codon substitution model with be {0} version '
                    'of YNGKP (Yang, Nielsen, Goldman, & Pederson. Genetics. '
                    '155:431-449).').format(modelvariant))
            e_pw = scipy.ones((3,phydmslib.constants.N_NT), dtype='float')
            for p in range(3):
                for (w, nt) in phydmslib.constants.INDEX_TO_NT.items():
                    e_pw[p][w] = sum([list(seq)[p::3].count(nt) for (head, seq)
                            in alignment])
            e_pw = e_pw / e_pw.sum(axis=1)[0]
            nsites = int(len(alignment[0][1]) / 3)
            model = phydmslib.models.YNGKP_M0(e_pw, nsites, freeparams=
                    ['mu', 'omega', 'kappa'])
            if modelvariant == 'M0':
                pass
            elif modelvariant == 'M5':
                logger.info(('For this {0} model, omega will be drawn from '
                        '{1} gamma-distributed categories.').format(
                        args['model'], args['ncats']))
                model = phydmslib.models.GammaDistributedOmegaModel(
                        model, args['ncats'])
            else:
                raise ValueError("Invalid variant {0} in {1}".format(
                        modelvariant, args['model']))
            prefslist = None
        elif (isinstance(args['model'], tuple) and len(args['model']) == 2 and
                args['model'][0] == 'ExpCM'):
            prefsfile = args['model'][1]
            logger.info(('The model will be an ExpCM informed by site-specific '
                    'amino-acid preferences in {0}').format(prefsfile))
            for (argname, desc) in [('avgprefs', 'averaged'),
                    ('randprefs', 'randomized')]:
                if args[argname]:
                    logger.info('Preferences will be {0} across sites.'.format(desc))
            prefs = phydmslib.file_io.readPrefs(prefsfile, minpref=args['minpref'],
                    avgprefs=args['avgprefs'], randprefs=args['randprefs'],
                    seed=args['seed'])
            sites = sorted(prefs.keys())
            prefslist = [prefs[r] for r in sites] # convert from dict to list
            assert len(prefs) == len(alignment[0][1]) // 3, ("The number of "
                    "preferences in {0} does not match the number of codon "
                    "sites in the alignment").format(prefsfile)
            logger.info(('Successfully read site-specific amino-acid preferences '
                    'for all {0} sites.\n').format(len(prefs)))
            freeparams = ['mu', 'kappa', 'omega', 'beta']
            if args['fitphi']:
                assert not args['divpressure'], (
                        "Can't use --divpressure and --fitphi")
                freeparams.append('eta')
                logger.info('Nucleotide frequency parameters phi will '
                        'be optimized by maximum likelihood.\n')
                model = phydmslib.models.ExpCM(prefslist, freeparams=freeparams)
            else:
                g = scipy.ndarray(phydmslib.constants.N_NT, dtype='float')
                for (w, nt) in phydmslib.constants.INDEX_TO_NT.items():
                    g[w] = sum([seq.count(nt) for (head, seq) in alignment])
                assert len(alignment) * len(prefs) * 3 == (g.sum() +
                        sum([seq.count('-') for (head, seq) in alignment])), (
                        "Alignment contains invalid nucleotide characters")
                g /= g.sum()
                logger.info('Nucleotide frequency parameters phi will be '
                        'set so stationary state matches alignment '
                        'nucleotide frequencies of {0}\n'.format(
                        ', '.join(['{0} = {1:.3f}'.format(nt, g[w]) for
                        (w, nt) in phydmslib.constants.INDEX_TO_NT.items()])))
                if not args['divpressure']:
                    model = phydmslib.models.ExpCM_empirical_phi(prefslist, g,
                        freeparams=freeparams)
                else:
                    for otherarg in ['omegabysite']:
                        if otherarg in args and args[otherarg]:
                            raise ValueError("Can't use --divpressure and "
                                    "--{0}".format(otherarg))
                    freeparams.append('omega2')
                    divpressure = phydmslib.file_io.readDivPressure(
                            args['divpressure'])
                    assert set(prefs.keys()) == set(divpressure.keys()), (
                            "The sites in {0} are different from {1}.".format(
                            args['divpressure'], prefsfile))
                    logger.info(('Read diversifying pressure from {0} '
                            'for all sites.').format(args['divpressure']))
                    divPressureSites = list(divpressure.keys())
                    divpressure = scipy.array([divpressure[x] for x in
                            sorted(divPressureSites)])
                    model = phydmslib.models.ExpCM_empirical_phi_divpressure(
                            prefslist, g, divpressure, freeparams=freeparams)
            if args['gammaomega']:
                logger.info(('Omega will be drawn from {0} gamma-distributed '
                            'categories.\n').format(args['ncats']))
                model = phydmslib.models.GammaDistributedOmegaModel(
                        model, args['ncats'])
        else:
            raise ValueError("Invalid model of %s" % args['model'])

        # read tree
        logger.info("Reading tree from %s" % args['tree'])
        tree = Bio.Phylo.read(args['tree'], 'newick')
        tipnames = set([clade.name for clade in tree.get_terminals()])
        assert len(tipnames) == tree.count_terminals(), "non-unique tip names?"
        assert tipnames == seqnames, ("Names in alignment do not match those in "
                "tree.\nSequences in alignment but NOT in tree:\n\t{0}\n"
                "Sequences in tree but NOT in alignment:\n\t{1}".format(
                '\n\t'.join(seqnames - tipnames), '\n\t'.join(tipnames - seqnames)))
        logger.info('Tree has {0} tips.'.format(len(tipnames)))
        tree.root_at_midpoint()
        assert tree.is_bifurcating(), "Tree is not bifurcating: cannot handle"
        nadjusted = 0
        for node in tree.get_terminals() + tree.get_nonterminals():
            if node.branch_length < args['minbrlen']:
                nadjusted += 1
                node.branch_length = args['minbrlen']
        logger.info('Adjusted {0} branch lengths up to minbrlen {1}\n'.format(
                nadjusted, args['minbrlen']))

        # set up tree likelihood
        logger.info('Initializing TreeLikelihood..')
        tl = phydmslib.treelikelihood.TreeLikelihood(tree, alignment, model)
        logger.info('TreeLikelihood initialized.')

        # maximize likelihood
        logger.info('Maximizing log likelihood (initially {0:.2f}).'.format(
                tl.loglik))
        if args['brlen'] == 'scale':
            optimize_brlen = False
            logger.info("Branch lengths will be scaled but not optimized "
                    "individually.")
        elif args['brlen'] == 'optimize':
            logger.info("Branch lengths will be optimized individually.")
            optimize_brlen = True
        else:
            raise ValueError("Invalid brlen {0}".format(args['brlen']))
        if args['profile']:
            import cProfile
            import pstats
            pstatsfile = '{0}_pstats'.format(args['outprefix'])
            logger.info('Maximizing with cProfile (probably slower).')
            logger.info('Profile stats will be in to {0}'.format(pstatsfile))
            maxresult = []
            def wrapper(maxresult): # wrapper to get return value from cProfile
                maxresult.append(tl.maximizeLikelihood(
                        optimize_brlen=optimize_brlen))
            cProfile.runctx('wrapper(maxresult)', globals(), locals(), pstatsfile)
            maxresult = maxresult[0]
            for psort in ['cumulative', 'tottime']:
                fname = '{0}_{1}.txt'.format(pstatsfile, psort)
                logger.info('Writing profile stats sorted by {0} to {1}'.format(
                        psort, fname))
                f = open(fname, 'w')
                s = pstats.Stats(pstatsfile, stream=f)
                s.strip_dirs()
                s.sort_stats(psort)
                s.print_stats()
                f.close()
        else:
            maxresult = tl.maximizeLikelihood(optimize_brlen=optimize_brlen)
        logger.info('Maximization complete:\n\t{0}'.format(
                maxresult.replace('\n', '\n\t')))
        logger.info('Optimized log likelihood is {0:.2f}.'.format(tl.loglik))
        logger.info('Writing log likelihood to {0}'.format(loglikelihoodfile))
        with open(loglikelihoodfile, 'w') as f:
            f.write('log likelihood = {0:.2f}'.format(tl.loglik))
        params = '\n\t'.join(['{0} = {1:6g}'.format(p, pvalue) for (p, pvalue)
                in sorted(tl.model.paramsReport.items())])
        logger.info('Model parameters after optimization:\n\t{0}'.format(params))
        logger.info('Writing model parameters to {0}'.format(modelparamsfile))
        with open(modelparamsfile, 'w') as f:
            f.write(params.replace('\t', ''))
        logger.info('Writing the optimized tree to {0}\n'.format(treefile))
        Bio.Phylo.write(tl.tree, treefile, 'newick')

        # get number of cpus for multiprocessing
        if args['ncpus'] == -1:
            args['ncpus'] = multiprocessing.cpu_count()
        assert args['ncpus'] >= 1, "{0} CPUs specified".format(args['ncpus'])

        # optimize a different omega for each site
        if args['omegabysite']:
            logger.info("\nFitting a different omega to each site to "
                    "detect diversifying selection.")
            if args['omegabysite_fixsyn']:
                fixsynstr = 'Synonymous rate will be fixed across sites.'
            else:
                fixsynstr = 'Will fit different synonymous rate for each site.'
            logger.info(fixsynstr)
            logger.info("Now fitting with {0} CPUs...".format(args['ncpus']))
            pool = multiprocessing.Pool(args['ncpus'])
            omegaresults = pool.map(fitOmegaBySite, map(treeliksForOmegaBySite,
                    range(1, tl.nsites + 1), itertools.repeat(tl, tl.nsites), 
                    itertools.repeat(prefslist, tl.nsites),
                    itertools.repeat(args['omegabysite_fixsyn'], tl.nsites)))
            pool.close()
            pool.join()
            logger.info("Completed fitting the site-specific omega values.")
            logger.info("Writing results to {0}\n".format(omegafile))
            with open(omegafile, 'w') as f:
                f.write('# Omega fit to each site after fixing tree and '
                        'all other parameters.\n# Fits compared to null model '
                        'of omega = 1.\n# P-values NOT corrected for multiple '
                        'hypothesis testing.\n# {0}\n#\n'
                        '# site\tomega\tP\tdLnL\n{1}'.format(fixsynstr,
                        '\n'.join([tup[1] for tup in sorted(omegaresults)])))

    except:
        logger.exception('Terminating %s at %s with ERROR' % (prog, time.asctime()))
        raise
    else:
        logger.info('Successful completion of %s' % prog)
    finally:
        logging.shutdown()



if __name__ == '__main__':
    main() # run the script
